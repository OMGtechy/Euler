// https://projecteuler.net/problem=12
// Highly divisible triangular number
// Problem 12
//
// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
//
// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
// Let us list the factors of the first seven triangle numbers :
//
// 1 : 1
// 3 : 1, 3
// 6 : 1, 2, 3, 6
// 10 : 1, 2, 5, 10
// 15 : 1, 3, 5, 15
// 21 : 1, 3, 7, 21
// 28 : 1, 2, 4, 7, 14, 28
//
// We can see that 28 is the first triangle number to have over five divisors.
//
// What is the value of the first triangle number to have over five hundred divisors?

#include <iostream>
#include <cstdint>
#include <cassert>
#include <algorithm>

#include "eulib_primes.h"

using IntegerType = int32_t;

IntegerType getTriangleNumber(const IntegerType n) {
	// Triangle numbers : 1, 3, 6, 10, 15, 21, 28, 36, 45, 55
	// The gap appears to increase by 1 between each number,
	// so this isn't linear. Therefore trying to derive a quadratic seems a good next step...
	// 
	// The quadratic equation is :
	// 
	// y = ax ^ 2 + bx + c
	// 
	// Where x = n and y = nth term.
	// 
	// Taking the first 3 points:
	// 
	// 1 = 1 ^ 2a + 1b + c
	// 1 = a + b + c
	// 
	// 3 = 2 ^ 2a + 2b + c
	// 3 = 4a + 2b + c
	// 
	// 6 = 3 ^ 2a + 3b + c
	// 6 = 9a + 3b + c
	// 
	// Eliminating c with the first and second:
	// 
	// 1 = a + b + c
	// 3 = 4a + 2b + c
	// 
	// Subtract the first from second :
	// 
	// 3 - 1 = 4a - a + 2b - b + c - c
	// 2 = 3a + b
	// 
	// Eliminating c with the first and third :
	// 
	// 1 = a + b + c
	// 6 = 9a + 3b + c
	// 
	// Subtract the first from third :
	// 
	// 6 - 1 = 9a - a + 3b - b + c - c
	// 5 = 8a + 2b
	// 
	// Taking the two equations with c eliminated :
	// 
	// 2 = 3a + b
	// 5 = 8a + 2b
	// 
	// Double the top equation :
	// 
	// 2(2) = 2(3a + b)
	// 4 = 6a + 2b
	// 
	// Now subtract the first from second :
	// 
	// 5 - 4 = 8a - 6a + 2b - 2b
	// 1 = 2a
	// 1 / 2 = a
	// a = 1 / 2
	// 
	// Now to solve for b:
	// 
	// 4 = 6a + 2b
	// 4 = 1 / 2(6) + 2b
	// 4 = 3 + 2b
	// 4 - 3 = 2b
	// 1 = 2b
	// 1 / 2 = b
	// 
	// Now to solve for c:
	// 
	// 3 = 4a + 2b + c
	// 3 = 1 / 2(4) + 1 / 2(2) + c
	// 3 = 2 + 1 + c
	// 
	// 3 = 3 + c
	// 3 - 3 = c
	// 0 = c
	// 
	// The whole equation now looks like this:
	// 
	// y = (x ^ 2) / 2 + x / 2
	// 
	// To check it works, let's see if plugging n = 4 into it gets 10
	// 
	// 10 = (4 ^ 2) / 2 + 4 / 2
	// 10 = 16 / 2 + 2
	// 10 = 8 + 2
	// 10 = 10
	// 
	// Once more, out of paranoia, for n = 5 (which should be 15) :
	// 
	// y = (x ^ 2) / 2 + x / 2
	// y = (5 ^ 2) / 2 + 5 / 2
	// y = 25 / 2 + 2.5
	// y = 12.5 + 2.5
	// y = 15
	return static_cast<IntegerType>(std::pow(n, 2) / 2.0 + (static_cast<double>(n) / 2.0));
}

IntegerType getNumberOfFactors(const IntegerType n, const std::set<IntegerType>& primes = {}) {
	if (n == 0) {
		return 0;
	}

	const auto primeFactors = eulib::getPrimeFactors<IntegerType>(n, primes);
	
	IntegerType factors = 1;
	for (auto prime : primeFactors) {
		factors *= prime.second + 1;
	}

	return factors;
}

IntegerType solution(const IntegerType numberOfDivisorsRequired) {
	const auto primes = eulib::getPrimes<IntegerType>([](auto primes) { return primes.size() < 100000; });

	for (IntegerType n = 0;; ++n) {
		const auto triangleNumber = getTriangleNumber(n);
		if (getNumberOfFactors(triangleNumber, primes) >= numberOfDivisorsRequired) {
			return triangleNumber;
		}
	}
}

int main() {
	assert(getTriangleNumber(1) == 1);
	assert(getTriangleNumber(2) == 3);
	assert(getTriangleNumber(3) == 6);
	assert(getTriangleNumber(4) == 10);
	assert(getTriangleNumber(5) == 15);
	assert(getTriangleNumber(6) == 21);
	assert(getTriangleNumber(7) == 28);
	assert(getTriangleNumber(8) == 36);
	assert(getTriangleNumber(9) == 45);
	assert(getTriangleNumber(10) == 55);

	assert(getNumberOfFactors(1) == 1);
	assert(getNumberOfFactors(2) == 2);
	assert(getNumberOfFactors(10) == 4);
	assert(getNumberOfFactors(13) == 2);
	assert(getNumberOfFactors(100) == 9);
	assert(getNumberOfFactors(1000) == 16);
	assert(getNumberOfFactors(254) == 4);
	assert(getNumberOfFactors(255) == 8);
	assert(getNumberOfFactors(256) == 9);
	assert(getNumberOfFactors(42) == 8);
	assert(getNumberOfFactors(180) == 18);
	
	assert(solution(5 + 1) == 28);

	// +1 because the question says first to have *over* 500 divisors 
	std::cout << solution(500 + 1) << std::endl;
}